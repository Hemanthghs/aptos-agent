import sqlite3 from "sqlite3";
import { open, Database } from "sqlite";
;
import { DB_SCHEMA } from "./constants";
import { DatabaseAdapter } from "../../database";
import { Document } from "../../rag"

export class SQLiteAdapter implements DatabaseAdapter {
  private db: Database | null = null;
  private dbPath: string;

  constructor(dbPath: string) {
    this.dbPath = dbPath;
  }

  async init(): Promise<void> {
    this.db = await open({
      filename: this.dbPath,
      driver: sqlite3.Database,
    });
    await this.db.exec(DB_SCHEMA);
  }

  /**
   * Adds an array of documents to the knowledge base.
   * 
   * This method inserts the provided documents into the database. Each document must include
   * its content and precomputed embeddings. The `id` and `created_at` fields are automatically
   * generated by the database.
   * 
   * Important:
   * - The database connection must be initialized before calling this method.
   * 
   * @param documents - An array of `Document` objects containing content and embeddings.
   * @throws Error if the database connection is not initialized.
   * 
 */
  async addKnowledge(documents: Document[]): Promise<void> {
    if (!this.db) {
      throw new Error("database is not initialized");
    }

    const insertStmt = 'INSERT INTO documents (id, content, embedding, parent_id, is_full_text) VALUES (?, ?, ?, ?, ?)';
    for (const doc of documents) {
      await this.db.run(insertStmt, doc.id, doc.content, JSON.stringify(doc.embedding), doc.parentId || null, doc.isFullText || false);
    }
  }

  /**
     * Searches the knowledge base for documents relevant to the given query.
     * 
     * This method performs a text search using the `LIKE` operator on the content.
     * 
     * @param query - The search query string.
     * @param topK - The maximum number of documents to return.
     * @returns An array of `Document` objects.
     */
  async searchKnowledge(query: string, topK: number): Promise<Document[]> {
    if (!this.db) {
      throw new Error("Database is not initialized");
    }

    const searchQuery = `
        SELECT id, content, embedding, created_at, parent_id, is_full_text
            FROM documents
            WHERE content LIKE ?
            ORDER BY created_at DESC
            LIMIT ?
    `;

    const rows = await this.db.all(searchQuery, [`%${query}%`, topK]);

    return rows.map((row: any) => ({
      id: row.id,
      content: row.content,
      embedding: JSON.parse(row.embedding),
      created_at: new Date(row.created_at),
      parentId: row.parent_id,
      isFullText: row.is_full_text
    }));
  }

  /**
   * Searches the knowledge base using vector embeddings.
   * 
   * This method calculates cosine similarity between the provided query embedding
   * and each document's embedding. It returns the topK documents with the highest similarity.
   * 
   * @param queryEmbedding - The embedding vector to search with.
   * @param topK - The number of results to return.
   * @returns An array of documents sorted by similarity.
   */
  async searchByEmbedding(queryEmbedding: number[], topK: number): Promise<Document[]> {
    if (!this.db) {
      throw new Error("Database is not initialized");
    }

    const results =
      await this.db.all('SELECT id, content, embedding, created_at, parent_id, is_full_text FROM documents');

    const documentsWithScores = results.map((row: any) => {
      const embedding = JSON.parse(row.embedding) as number[];
      const similarity = this.calculateCosineSimilarity(queryEmbedding, embedding);

      return {
        document: {
          id: row.id,
          content: row.content,
          embedding,
          created_at: new Date(row.created_at),
          parentId: row.parent_id,
          isFullText: row.is_full_text
        },
        similarity
      };
    });

    const topDocuments = documentsWithScores
      .sort((a, b) => b.similarity - a.similarity)
      .slice(0, topK)
      .map(item => item.document);

    return topDocuments;
  }

  /**
   * Calculates cosine similarity between two embedding vectors.
   * 
   * @param vecA - First embedding vector.
   * @param vecB - Second embedding vector.
   * @returns The cosine similarity between vecA and vecB.
   */
  private calculateCosineSimilarity(vecA: number[], vecB: number[]): number {
    const dotProduct = vecA.reduce((sum, a, i) => sum + a * (vecB[i] || 0), 0);
    const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));
    const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));
    if (magnitudeA === 0 || magnitudeB === 0) return 0;
    return dotProduct / (magnitudeA * magnitudeB);
  }
}